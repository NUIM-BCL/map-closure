(letrec ((substitute
	  (lambda (x y z)
	   (cond ((equal? y z) x)
		 ((pair? z)
		  (cons (substitute x y (car z)) (substitute x y (cdr z))))
		 ((procedure? z)
		  (map-closure (lambda (n z) (substitute x y z)) z))
		 (else z))))
	 (lift-+ (lambda (+)
		  (lambda (x y)
		   (let ((x (if (pair? x) x (cons x 0)))
			 (y (if (pair? y) y (cons y 0))))
		    (cons (+ (car x) (car y)) (+ (cdr x) (cdr y)))))))
	 (with-complex (lambda (thunk) ((substitute (lift-+ +) + thunk)))))
 (let ((h (let ((p +)) (lambda (x) (p x 5)))))
  (with-complex (lambda () (h '(1 . 2))))))
